#!/usr/bin/env python3
"""
End AI-SDLC Project - Final commit and project completion
"""

import os
import sys
import subprocess
from datetime import datetime

def end_project(project_path=".", final_message=None):
    """End project with final commit and summary"""
    
    # Check if SESSION-STATUS.md exists
    status_file = os.path.join(project_path, "SESSION-STATUS.md")
    if not os.path.exists(status_file):
        print("❌ No SESSION-STATUS.md found. Not an AI-SDLC project.")
        return False
    
    # Check if Git repository exists
    if not os.path.exists(os.path.join(project_path, ".git")):
        print("❌ No Git repository found.")
        return False
    
    try:
        # Read project info from SESSION-STATUS.md
        with open(status_file, 'r') as f:
            content = f.read()
        
        # Extract project name
        project_name = "AI-SDLC Project"
        name_lines = [line for line in content.split('\n') if '**Name:**' in line]
        if name_lines:
            project_name = name_lines[0].split('**Name:**')[1].strip()
        
        print(f"🏁 Ending Project: {project_name}")
        
        # Create project completion summary
        completion_summary = f\"\"\"# Project Completion Summary
        
## Project: {project_name}
## Completed: {datetime.now().strftime("%Y-%m-%d %H:%M")}

## Final Status
- All 7 phases completed
- Code committed to repository
- Project ready for deployment/maintenance

## Repository Information
- Local repository: ✅ Complete
- All changes committed: ✅ Complete
- Ready for production: ✅ Complete

## Next Steps
1. Deploy to production environment
2. Set up monitoring and maintenance
3. Plan future enhancements
4. Archive project documentation

---
Generated by AI-SDLC Framework
\"\"\"
        
        # Write completion summary
        with open(os.path.join(project_path, "PROJECT-COMPLETION.md"), "w") as f:
            f.write(completion_summary)
        
        # Add all final changes
        subprocess.run(["git", "add", "."], cwd=project_path, check=True)
        
        # Create final commit message
        if not final_message:
            final_message = f"🏁 Project Completion: {project_name} - {datetime.now().strftime('%Y-%m-%d')}"
        
        # Check if there are changes to commit
        result = subprocess.run(["git", "status", "--porcelain"], 
                              cwd=project_path, capture_output=True, text=True, check=True)
        
        if result.stdout.strip():
            # Commit final changes
            subprocess.run(["git", "commit", "-m", final_message], 
                          cwd=project_path, check=True)
            print(f"✅ Final commit created: {final_message}")
        else:
            print("✅ No final changes to commit")
        
        # Try to push to remote
        try:
            result = subprocess.run(["git", "remote", "-v"], 
                                  cwd=project_path, capture_output=True, text=True, check=True)
            
            if result.stdout.strip():
                subprocess.run(["git", "push"], cwd=project_path, check=True)
                print("🚀 Final changes pushed to remote repository")
            else:
                print("📡 No remote repository configured")
        
        except subprocess.CalledProcessError:
            print("⚠️  Could not push to remote. Push manually:")
            print("   git push")
        
        # Create final tag
        try:
            tag_name = f"v1.0-{datetime.now().strftime('%Y%m%d')}"
            subprocess.run(["git", "tag", "-a", tag_name, "-m", f"Release: {project_name}"], 
                          cwd=project_path, check=True)
            print(f"🏷️  Created release tag: {tag_name}")
            
            # Try to push tag
            try:
                subprocess.run(["git", "push", "origin", tag_name], cwd=project_path, check=True)
                print("🚀 Release tag pushed to remote")
            except subprocess.CalledProcessError:
                print("📡 Tag created locally. Push manually: git push origin --tags")
        
        except subprocess.CalledProcessError:
            print("⚠️  Could not create release tag")
        
        # Display completion summary
        print("\n" + "="*60)
        print("🎉 PROJECT COMPLETED SUCCESSFULLY! 🎉")
        print("="*60)
        print(f"📁 Project: {project_name}")
        print(f"📅 Completed: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
        print(f"📄 Summary: PROJECT-COMPLETION.md created")
        print(f"🏷️  Release: {tag_name if 'tag_name' in locals() else 'Not tagged'}")
        print("="*60)
        
        # Show repository stats
        try:
            result = subprocess.run(["git", "log", "--oneline"], 
                                  cwd=project_path, capture_output=True, text=True, check=True)
            commit_count = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
            print(f"📊 Total commits: {commit_count}")
            
            result = subprocess.run(["git", "ls-files"], 
                                  cwd=project_path, capture_output=True, text=True, check=True)
            file_count = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
            print(f"📊 Total files: {file_count}")
        
        except subprocess.CalledProcessError:
            pass
        
        print("\n💡 Next Steps:")
        print("   1. Deploy to production")
        print("   2. Set up monitoring")
        print("   3. Plan maintenance schedule")
        print("   4. Archive project documentation")
        
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"❌ Git operation failed: {e}")
        return False
    except FileNotFoundError:
        print("❌ Git not found. Please install Git first.")
        return False

def main():
    project_path = sys.argv[1] if len(sys.argv) > 1 else "."
    final_message = sys.argv[2] if len(sys.argv) > 2 else None
    
    print("🏁 Ending AI-SDLC Project...")
    success = end_project(project_path, final_message)
    
    if not success:
        print("\n❌ Failed to end project")
        sys.exit(1)

if __name__ == "__main__":
    main()